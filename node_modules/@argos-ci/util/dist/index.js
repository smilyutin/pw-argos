import {
  getMetadataPath,
  getScreenshotName,
  validateThreshold
} from "./chunk-VMM7XHBS.js";

// src/fs.ts
import { randomBytes } from "crypto";
import { mkdir } from "fs/promises";
import { tmpdir } from "os";
import { join } from "path";
var createDirectoryPromises = /* @__PURE__ */ new Map();
async function createDirectory(pathname) {
  let promise = createDirectoryPromises.get(pathname);
  if (promise) {
    return promise;
  }
  promise = mkdir(pathname, { recursive: true }).then(() => {
  });
  createDirectoryPromises.set(pathname, promise);
  return promise;
}
async function createTemporaryDirectory() {
  const osTmpDirectory = tmpdir();
  const path = join(osTmpDirectory, "argos." + randomBytes(16).toString("hex"));
  await createDirectory(path);
  return path;
}

// src/git.ts
import { exec } from "child_process";
var cached;
function getGitRepositoryPath() {
  if (!cached) {
    cached = new Promise((resolve) => {
      exec("git rev-parse --show-toplevel", (error, stdout, stderr) => {
        if (error) {
          resolve(null);
        }
        if (stderr) {
          resolve(null);
        }
        resolve(stdout.trim());
      });
    });
  }
  return cached;
}

// src/introspection.ts
import { readFile } from "fs/promises";
var versionCache = /* @__PURE__ */ new Map();
function readVersionFromPackage(pkgPath) {
  const readVersion = async () => {
    const { version } = JSON.parse(await readFile(pkgPath, "utf-8"));
    if (typeof version !== "string") {
      throw new Error("Invalid version");
    }
    return version;
  };
  if (!versionCache.has(pkgPath)) {
    versionCache.set(pkgPath, readVersion());
  }
  const fromCache = versionCache.get(pkgPath);
  if (!fromCache) {
    throw new Error("Invariant violation: version not in cache");
  }
  return fromCache;
}

// src/metadata-io.ts
import { readFile as readFile2, writeFile } from "fs/promises";
async function writeMetadata(screenshotPath, metadata) {
  await writeFile(getMetadataPath(screenshotPath), JSON.stringify(metadata));
}
async function readMetadata(screenshotPath) {
  try {
    const metadata = await readFile2(getMetadataPath(screenshotPath), "utf8");
    return JSON.parse(metadata);
  } catch (error) {
    if (error instanceof Error && "code" in error && error.code === "ENOENT") {
      return null;
    }
    throw new Error("Failed to read metadata", { cause: error });
  }
}

// src/playwright-trace.ts
import { access } from "fs/promises";
function getTracePath(screenshotPath) {
  return screenshotPath + ".pw-trace.zip";
}
async function getPlaywrightTracePath(screenshotPath) {
  try {
    const tracePath = getTracePath(screenshotPath);
    await access(tracePath);
    return tracePath;
  } catch {
    return null;
  }
}
export {
  createDirectory,
  createTemporaryDirectory,
  getGitRepositoryPath,
  getMetadataPath,
  getPlaywrightTracePath,
  getScreenshotName,
  readMetadata,
  readVersionFromPackage,
  validateThreshold,
  writeMetadata
};
